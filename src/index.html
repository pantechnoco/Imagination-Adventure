<html>
    <head>
        <title>Imagine Adventure</title>
        <style>
            #canvas {
                width: 512px;
                height: 512px;
            }
        </style>
    </head>
    <body onload="init()">
        <canvas id="canvas" width="128" height="128" />
        <script type="text/javascript">
        var canvas
        ,   engine
        ,   viewport
        ,   ctx
        ,   layers
        ,   sprites
        ,   tileset
        ,   now

        ,   TILEWIDTH
        ,   JUMPHEIGHT = 24
        ,   WALK_SPEED = 250

        ,   health = 100
        ,   jumping = JUMPHEIGHT
        ,   falling = false
        ,   landed = false

        ,   K_LEFT = 37
        ,   K_UP = 38
        ,   K_RIGHT = 39
        ,   K_DOWN = 40
        ,   K_SPACE = 32

        ,   T_TRANSPARENT = 0
        ,   T_WHITE = 63
        ,   T_BLACK = 7
        ,   T_GRAY = 31
        ,   T_GRAY = 31
        ,   T_LTBLUE = 12
        ,   T_BOX = 49
        ,   T_SPIKE1 = 50
        ,   T_SPIKE2 = 51
        ,   T_PLHEAD = 10
        ,   T_PLFEET1 = 17
        ,   T_PLFEET2 = 18
        ,   T_PLFEET3 = 19
        ;

        function Viewport() {
            this.x = 0;
            this.y = 0;
            this.width = TILEWIDTH;
            this.height = TILEWIDTH;
        };
        Viewport.prototype.draw = function() {
            
        };

        function Layer(h, w, inworld) {
            this.height = h;
            this.width = w;
            this.inworld = !!inworld;
            for (var h_i=0; h_i<h; h_i++) {
                for (var w_i=0; w_i<w; w_i++) {
                    this.push(T_TRANSPARENT);
                }
            }
        };
        Layer.prototype = (new Array());
        Layer.prototype.draw = function() {
            var x, y
            ,   offx = this.inworld ? viewport.x : 0
            ,   offy = this.inworld ? viewport.y : 0
            ;
            for (x=0; x<this.width; x++) {
                for (y=0; y<this.height; y++) {
                    engine.blit(this.get(x, y), x*8 + offx, y*8 + offy);
                }
            }
        };
        Layer.prototype.setAll = function(t) {
            var x, y, i, l = this.width * this.height;
            for (i=0; i<l; i++) {
                this[i] = t;
            }
        };
        Layer.prototype.get = function(x, y) {
            var i = (y * this.width) + x
            ,   t = this[i]
            ;
            return t;
        };
        Layer.prototype.set = function(x, y, t) {
            var i = (y * this.width) + x
            ;
            this[i] = t;
        };
        Layer.prototype._debug_map = function() {
            var x, y, l, t;
            for (y=0; y<this.height; y++) {
                l = []
                for (x=0; x<this.width; x++) {
                    try {
                        t = this.get(x, y).toString(16);
                    } catch (e) {
                        t = "--";
                    }
                    if (t.length == 1) {
                        t = ["0" + t].join("");
                    }
                    l.push(t);
                }
                console.debug(l);
            }
        };

        function Sprite(x, y, t) {
            this.x = x;
            this.y = y;
            this.t = t;
        }
        Sprite.prototype.draw = function() {
            engine.blit(this.t, this.x, this.y);
        };
        Sprite.prototype.tick = function() {

        };

        function SpriteGroup(x, y, sprites, inworld) {
            this.x = x;
            this.y = y;
            this.dy = 0;
            this.sprites = sprites;
            this.inworld = !!inworld;
        }
        SpriteGroup.prototype.draw = function() {
            var sl = this.sprites.length
            ,   i
            ,   s
            ,   x = this.x
            ,   y = this.y
            ,   offx = this.inworld ? viewport.x : 0
            ,   offy = this.inworld ? viewport.y : 0
            ;
            for (i=0; i<sl; i++) {
                s = this.sprites[i];
                engine.blit(s.t, x+s.x+offx, y+s.y+offy);
            }
        };
        SpriteGroup.prototype.hurt = function(h) {
            health -= h;
            engine.update_health();
        };
        SpriteGroup.prototype.tick = function() {
            var ty = parseInt((this.y + 8) / 8)
            ,   tx = parseInt(this.x / 8)
            ,   under_1 = layers[2].get(tx, ty)
            ,   under_2 = layers[2].get(tx+1, ty)
            ;

            /* DEBUG LANDING SPACES
            if (under_1 !== 0) {
                layers[2].set(tx, ty, 5);
            }
            if (under_2 !== 0) {
                layers[2].set(tx+1, ty, 5);
            }
            /**/

            if (under_1 === 0 && under_2 === 0) {
                if (this.dy === 0)
                    this.dy = 0.75;
                else
                    this.dy += 0.025 
                this.move(0, this.dy);
                falling = true;
            } else if (under_1 === T_SPIKE1 || under_2 === T_SPIKE1 || under_1 === T_SPIKE2 || under_2 === T_SPIKE2) {
                this.move(0, -16);
                this.hurt(10);
            } else {
                this.dy = 0;
                if (falling)
                    landed = true;
                falling = false;
                jumping = JUMPHEIGHT
            }
        };
        SpriteGroup.prototype.move = function(x, y) {
            var ty = this.y / 8
            ,   tx = (this.x % 8)===0 ? (this.x/8)+(x<0?-1:1) : (this.x/8)
            ,   l = layers[2]
            ,   left = l.get(Math.floor(tx), Math.ceil(ty))===0
            ,   right = l.get(Math.ceil(tx), Math.ceil(ty))===0
            ;

            if ((x > 0 && right) || (x < 0 && left)) {
                this.x += parseInt(x);
                this.sprites[1].t = [T_PLFEET1, T_PLFEET2, T_PLFEET3][parseInt((now % WALK_SPEED) / (WALK_SPEED/3))];
            } else {
                this.sprites[1].t = T_PLFEET2;
            }
            this.y += parseInt(y);
        }

        function init() {
            engine = new Engine();

        }

        function Engine() {
            this.keystate = keystate = [];
            window.onkeydown = function(e) {
                keystate[e.keyCode] = true;
                return false;
            }
            window.onkeyup = function(e) {
                keystate[e.keyCode] = false;
                return false;
            }

            this.last_frame;
            this.canvas = document.getElementById('canvas');
            this.ctx = this.canvas.getContext('2d');
            this.tilesets = [];

            TILEWIDTH = this.canvas.getAttribute('width') / 8;

            viewport = new Viewport();

            layers = [];
            layers.push(new Layer(TILEWIDTH, TILEWIDTH));
            layers.push(new Layer(TILEWIDTH, TILEWIDTH, true));
            layers.push(new Layer(TILEWIDTH, TILEWIDTH * 10, true));
            layers.push(new Layer(TILEWIDTH, TILEWIDTH));

            sprites = [];
            sprites.push(new SpriteGroup(50, 50, [
                new Sprite(0, -8, T_PLHEAD)
            ,   new Sprite(0,  0, T_PLFEET2)
            ], true));

            layers[3][0] = 65;
            layers[3][1] = 64;
            layers[3][2] = 64;

            for (var y=5; y<12; y++) {
                layers[2].set(0, y, T_BOX);
                layers[2].set(layers[2].width, y, T_BOX);
            }
            
            for (var i=0; i<layers[2].width; i++) {
                if (Math.random() > 0.8) {
                    layers[2].set(i, 11, T_BOX);
                }
                layers[2].set(i, 12, 28);
                layers[2].set(i, 13, 27);
                layers[2].set(i, 14, 27);
                layers[2].set(i, 15, 27);
            }

            layers[2].set(15, 11, 0);
            layers[2].set(16, 11, 0);
            layers[2].set(17, 11, 0);
            layers[2].set(15, 12, 0);
            layers[2].set(16, 12, 0);
            layers[2].set(17, 12, 0);
            layers[2].set(15, 13, T_SPIKE1);
            layers[2].set(16, 13, T_SPIKE2);
            layers[2].set(17, 13, T_SPIKE1);

            layers[0].setAll(T_LTBLUE);

            this.loadTilesets("tileset.png", "alphanum.png");
        }
        Engine.prototype.loadTilesets = function() {
            var tileset
            ,   to_load = arguments.length
            ,   engine = this
            ;

            for (var i=0; i<arguments.length; i++) {
                tileset = new Image();
                this.tilesets.push(tileset)
                tileset.onload = function() {
                    to_load -= 1; 
                    if (to_load === 0) {
                        engine.start()
                    }
                };
                tileset.src = arguments[i] + "?ts=" + (new Date().toISOString());
            }

        }
        Engine.prototype.blit = function blit(i, x, y) {
            var sx = (i % 64) % 8
            ,   sy = parseInt((i % 64) / 8)
            ,   tileset = this.tilesets[parseInt(i / 64)]
            ;
            if (x >= 0 && x < 128 && y >= 0 && y < 128) {
                this.ctx.drawImage(tileset, sx*8, sy*8, 8, 8, x, y, 8, 8);
            }
        }
        Engine.prototype.start = function start() {
            this.update_health();

            layers[0].draw();
            layers[1].draw();

            var sl = sprites.length, si;
            for (si=0; si<sl; si++) {
                sprites[si].draw();
                sprites[si].tick();
            }

            layers[2].draw();
            layers[3].draw();

            requestAnimFrame(function(){
                engine.tick()
            });
        }
        Engine.prototype.tick = function() {
            var redraw = false;
            now  = new Date();
            if (typeof this.last_frame != "undefined") {
                // console.debug(parseInt(1000 / (now.getTime() - this.last_frame.getTime())) + " fps");
            }
            this.last_frame = now;

            var sl = sprites.length, si;
            for (si=0; si<sl; si++) {
                sprites[si].tick();
            }

            if (this.keystate[K_RIGHT]) {
                sprites[0].move(1, 0);
                redraw = true;
            } else if (this.keystate[K_LEFT]) {
                sprites[0].move(-1, 0);
                redraw = true;
            }
            if (this.keystate[K_SPACE] && jumping > 0 && !(falling && jumping==JUMPHEIGHT)) {
                if (!landed) {
                    sprites[0].move(0, parseInt(-3 * Math.sin(jumping/JUMPHEIGHT)));
                    jumping -= 1;
                    redraw = true;
                }
            }
            if (falling)
                redraw = true;
            if (!this.keystate[K_SPACE]) {
                landed = false;
            }

            if (sprites[0].x + viewport.x < TILEWIDTH*8 / 3) {
                viewport.x += 1;
            } else if (sprites[0].x + viewport.x > TILEWIDTH*8 / 1.5) {
                viewport.x -= 1;
            }

            if (redraw) {
                layers[0].draw();
                layers[1].draw();
                sprites[0].draw();
                layers[2].draw();
                layers[3].draw();
            }

            requestAnimFrame(function() {
                engine.tick();
            });
        }
        Engine.prototype.update_health = function() {
            var t = health % 33
            ,   i = parseInt(t/(33/8))
            ,   p = health===100 ? 120 : 127 - i
            ;

            console.debug(t, i, p);

            layers[3][13] = health <= 33 ? p : 120;
            layers[3][14] = health <= 66 && health > 33 ? p : (health < 33 ? 0 : 120);
            layers[3][15] = health > 66 ? p : 0;
        }

        /**
         * Provides requestAnimationFrame in a cross browser way.
         */
        window.requestAnimFrame = (function() {
          return window.requestAnimationFrame ||
                 window.webkitRequestAnimationFrame ||
                 window.mozRequestAnimationFrame ||
                 window.oRequestAnimationFrame ||
                 window.msRequestAnimationFrame ||
                 function(/* function FrameRequestCallback */ callback, /* DOMElement Element */ element) {
                   window.setTimeout(callback, 1000/60);
                 };
        })();
        </script>
    </body>
</html>
